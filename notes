Problems:

Optimisations:
    a) `find move` -> when searching for moves, looking through a list instead of a set (use (Set Move) instead of [Move] ?)
    b) `king` and `pawn` parsers -> these two have a dependency on parse-order. This shouldn't be.
    
To Do:
     * 1. Add proper checkmate verification
     * 2. Implement proper rendering for the board
     * 3. Implement a game interface
     * 4. Implement parsing of game outcomes -> never interpret a pre-existing PGN game into a termination
     * 5. Add stalemate checks
     * 6 Fix PGN header parser to account for misshaps in ordering + add the other additional  fields a file might have
     * 7. Implement evaluation steps for a Board
     * 8. Implement all PGN tags
     * 9. Implement translation from Moves -> PGN
     * 10. Refine the API:
           * -> ! Define a different Parser (one with a more general game-oriented concern) in `Sim` and use that both there and include `Play` 
           * -> Add a `Sim` module where one can simluate chess games fairly arbitrarily
           * -> Try to use this in the `Play` module
           * -> Move all `Chess` related types to the main `Chess.hs` file and use those types everywhere else.
           * -> Move migrate the mostly external usage of `Internal` files to `API` files (example: Play.hs uses internal to distinguish between colours)
     * 11. Add a typeclass in-between the parser I use (Megaparsec) and the outer world. People might be using some other parser for their implementation
     * 12. Move the concrete `Parser` to `Play` and just derive a `Bridge` instance for it that you use in conjunction with whatever `Chess` gives you
   12.5. Make `Play` have it's own errors ?
   12.x1. Add Show for tags
      x2. Write PGN show for an entire pgn file
   13. Write a read-me, documentation and release
   14. Add some more tests:
       -> Parser 
       -> Checks
       -> Checkmates
       -> Writer (moves, position)
   15. Complete game interface (print game as PGN file out when exiting or resigning)  
   15. Add an engine to play against
   16. Add in-game draw suggestions checks
   17. Patch the PGN parser to parse  bytestrings directly. (Text.Megaparsec.Byte)
   18. Encode the ambiguity of a move directly when parsing, either in the board, or with the move itself, so that serialisation is less of a burden
   19. The problem with Haskell is that people don't really like its `String` type. Many of them preferring Text.
       Could be that others might be using `ByteString` (for some idiotic reason).
       Either-way, perhaps I should generify the PGN parser so that it may accept any `s` as input and by means of type-class do parsing.